-- Basic CASE statements

-- similar to IF statement in other programs

--Syntax:
CASE WHEN ___ THEN ___
     WHEN ___ THEN ___
     ELSE ___ END 

-- Identify the home team as Bayern Munich, Schalke 04, or neither
SELECT 
	CASE WHEN hometeam_id = 10189 THEN 'FC Schalke 04'
        wHEN hometeam_id = 9823 THEN 'FC Bayern Munich'
         ELSE 'Other' END AS home_team,
	COUNT(id) AS total_matches
FROM matches_germany
-- Group by the CASE statement alias
GROUP BY home_team;

-- Select the date of the match and create a CASE statement to identify matches as home wins, home losses, or ties.
SELECT 
	-- Select the date of the match
	date,
	-- Identify home wins, losses, or ties
	CASE WHEN home_goal > away_goal THEN 'Home win!'
        WHEN home_goal < away_goal THEN 'Home loss :(' 
        ELSE 'Tie' END AS outcome
FROM matches_spain;



-- Complex CASE clauses:

-- we can write more complex CASE clauses using conditional expressions with AND, OR

SELECT 
	date,
	-- Identify the home team as Barcelona or Real Madrid
	CASE WHEN hometeam_id = 8634 THEN 'FC Barcelona' 
        ELSE 'Real Madrid CF' END AS home,
    -- Identify the away team as Barcelona or Real Madrid
	CASE WHEN awayteam_id = 8634 THEN 'FC Barcelona' 
        ELSE 'Real Madrid CF' END AS away
FROM matches_spain
WHERE (awayteam_id = 8634 OR hometeam_id = 8634)
      AND (awayteam_id = 8633 OR hometeam_id = 8633);
      

-- Filtering your CASE statement
-- using your CASE statement as a filter in the WHERE clause
-- you can use a CASE statement as a filter in the WHERE statement to remove output you don't want to see.
SELECT *
FROM table
WHERE 
    CASE WHEN a > 5 THEN 'Keep'
         WHEN a <= 5 THEN 'Exclude' END = 'Keep';       -- > Here End result is only set to 'Keep' results
         


-- Use the CASE statement in the WHERE clause to filter all NULL values generated by the statement
-- Select the season, date, home_goal, and away_goal columns
SELECT 
	season,
    date,
	home_goal,
	away_goal
FROM matches_italy
WHERE 
-- Exclude games not won by Bologna
	CASE WHEN hometeam_id = 9857 AND home_goal > away_goal THEN 'Bologna Win'
		WHEN awayteam_id = 9857 AND away_goal > home_goal THEN 'Bologna Win' 
		END IS NOT NULL;
    
    -- in above End result is set to non-Null values
    


-- CASE WHEN with aggregate functions

SELECT 
	c.name AS country,
    -- Count matches in each of the 3 seasons
	COUNT(CASE WHEN m.season = '2012/2013' THEN m.id END) AS matches_2012_2013,
	COUNT(CASE WHEN m.season = '2013/2014' THEN m.id END) AS matches_2013_2014,
	COUNT(CASE WHEN m.season = '2014/2015' THEN m.id END) AS matches_2014_2015
FROM country AS c
LEFT JOIN match AS m
ON c.id = m.country_id
-- Group by country name alias
GROUP BY country;


-- Exercise: Your goal here is to use the country and match table to determine the total number of matches 
--won by the home team in each country during the 2012/2013, 2013/2014, and 2014/2015 seasons

SELECT 
	c.name AS country,
    -- Sum the total records in each season where the home team won
	SUM(CASE WHEN m.season = '2012/2013' AND m.home_goal > m.away_goal 
        THEN 1 ELSE 0 END) AS matches_2012_2013,
 	SUM(CASE WHEN m.season = '2013/2014' AND m.home_goal > m.away_goal 
        THEN 1 ELSE 0 END) AS matches_2013_2014,
	SUM(CASE WHEN m.season = '2014/2015' AND m.home_goal > m.away_goal
        THEN 1 ELSE 0 END) AS matches_2014_2015
FROM country AS c
LEFT JOIN match AS m
ON c.id = m.country_id
-- Group by country name alias
GROUP BY country;



-- CASE WITH AVG
--Calculate the percentage of matches tied using a CASE statement inside AVG.

SELECT 
	c.name AS country,
    -- Calculate the percentage of tied games in each season
	AVG(CASE WHEN m.season='2013/2014' AND m.home_goal = m.away_goal THEN 1
			WHEN m.season='2013/2014' AND m.home_goal <> m.away_goal THEN 0
			END) AS ties_2013_2014,
	AVG(CASE WHEN m.season='2014/2015' AND m.home_goal = m.away_goal THEN 1
			WHEN m.season='2014/2015' AND m.home_goal <> m.away_goal THEN 0
			END) AS ties_2014_2015
FROM country AS c
LEFT JOIN matches AS m
ON c.id = m.country_id
GROUP BY country;

-- Same as above with rounded values:
SELECT 
	c.name AS country,
    -- Round the percentage of tied games to 2 decimal points
	ROUND(AVG(CASE WHEN m.season='2013/2014' AND m.home_goal = m.away_goal THEN 1
			 WHEN m.season='2013/2014' AND m.home_goal != m.away_goal THEN 0
			 END),2) AS pct_ties_2013_2014,
	ROUND(AVG(CASE WHEN m.season='2014/2015' AND m.home_goal = m.away_goal THEN 1
			 WHEN m.season='2014/2015' AND m.home_goal != m.away_goal THEN 0
			 END),2) AS pct_ties_2014_2015
FROM country AS c
LEFT JOIN matches AS m
ON c.id = m.country_id
GROUP BY country;



-- Subqueries in WHERE clause

SELECT 
	-- Select the team long and short names
	team_long_name,
	team_short_name
FROM team 
-- Exclude all values from the subquery
WHERE team_api_id NOT IN
     (SELECT DISTINCT hometeam_ID  FROM match);
     


-- Subqueries in FROM

-- we need to give an alias to the subquery table in FROM statement

SELECT
	-- Select country name and the count match IDs
    name AS country_name,
    COUNT(*) AS matches
FROM country AS c
-- Inner join the subquery onto country
-- Select the country id and match id columns
INNER JOIN (SELECT country_id, id 
           FROM match
           -- Filter the subquery by matches with 10+ goals
           WHERE (home_goal + away_goal) >= 10) AS sub
ON c.id = sub.country_id
GROUP BY country_name;



-- Subqueries in SELECT

-- Subqueries in SELECT statement need to return only one output

SELECT 
	l.name AS league,
    -- Select and round the league's total goals
    ROUND(AVG(m.home_goal + m.away_goal), 2) AS avg_goals,
    -- Select & round the average total goals for the season
    (SELECT ROUND(AVG(home_goal + away_goal), 2) 
     FROM match
     WHERE season = '2013/2014') AS overall_avg
FROM league AS l
LEFT JOIN match AS m
ON l.country_id = m.country_id
-- Filter for the 2013/2014 season
WHERE season = '2013/2014'
GROUP BY league;

-- Output:
league	avg_goals	overall_avg
Switzerland Super League2.89	2.77
Poland Ekstraklasa	2.64	2.77
Netherlands Eredivisie	3.20	2.77
Scotland Premier League	2.75	2.77 
...


-- Below, we added a subquery in SELECT to compare the average number of goals scored in each stage to the total.

SELECT 
	-- Select the stage and average goals from s
	stage,
    ROUND(avg_goals,2) AS avg_goal,
    -- Select the overall average for 2012/2013
    (SELECT AVG(home_goal + away_goal) 
                    FROM match WHERE season = '2012/2013') AS overall_avg
FROM 
	-- Select the stage and average goals in 2012/2013 from match
	(SELECT
		 stage,
         AVG(home_goal + away_goal) AS avg_goals
	 FROM match
	 WHERE season = '2012/2013'
	 GROUP BY stage) AS s
WHERE 
	-- Filter the main query using the subquery
	s.avg_goals > (SELECT AVG(home_goal + away_goal) 
                    FROM match WHERE season = '2012/2013');
		    
-- Result:
stage	avg_goal	overall_avg
4	2.80	2.7726993865030675
10	2.96	2.7726993865030675
38	3.17	2.7726993865030675
6	2.78	2.7726993865030675
12	3.23	2.7726993865030675




-- Correlated subqueries

-- uses values from outer query to get results
-- evaluated for each row of the outer query, so takes time, SLOWS DOWN the code
--Correlated subqueries are subqueries that reference one or more columns in the main query. 
--Correlated subqueries depend on information in the main query to run, and thus, cannot be executed on their own.
--Correlated subqueries are evaluated in SQL once per row of data retrieved -- a process that takes a lot more computing power and time than a simple subquery.

SELECT 
	-- Select country ID, date, home, and away goals from match
	main.country_id,
    main.date,
    main.home_goal,
    main.away_goal
FROM match AS main
WHERE 
	-- Filter for matches with the highest number of goals scored ( THIS IS CORRELATED QUERY)
	(home_goal + away_goal) = 
        (SELECT MAX(sub.home_goal + sub.away_goal)
         FROM match AS sub
         WHERE main.country_id = sub.country_id
               AND main.season = sub.season);
	       


-- NESTED SUBQUERY
-- Nested subqueries can be either simple or correlated.
-- Just like an unnested subquery, a nested subquery's components can be executed independently of the outer query, 
--while a correlated subquery requires both the outer and inner subquery to run and produce results.

SELECT
	-- Select the season and max goals scored in a match
	season,
    MAX(home_goal + away_goal) AS max_goals,
    -- Select the overall max goals scored in a match
   (SELECT MAX(home_goal + away_goal) FROM match) AS overall_max_goals,
   -- Select the max number of goals scored in any match in July
   (SELECT MAX(home_goal + away_goal) 
    FROM match
    WHERE id IN (
          SELECT id FROM match WHERE EXTRACT(MONTH FROM date) = 07)) AS july_max_goals
FROM match
GROUP BY season;

-Result:
season	max_goals	overall_max_goals	july_max_goals
2013/2014	10		11		7
2012/2013	11		11		7
2014/2015	10		11		7
2011/2012	10		11		7


-- Exercise:
-- Select matches where a team scored 5+ goals
SELECT
	country_id,
    season,
	id
FROM match
WHERE home_goal > 5 OR away_goal > 5;

-- COUNT the match ids generated in the previous step, and group the query by country_id and season.
-- Count match ids
SELECT
    country_id,
    season,
    COUNT(id) AS matches
-- Set up and alias the subquery
FROM (
	SELECT
    	country_id,
    	season,
    	id
	FROM match
	WHERE home_goal >= 5 OR away_goal >= 5) 
    AS subquery
-- Group by country_id and season
GROUP BY country_id, season;


--Finally, declare the same query from step 2 as a subquery in FROM with the alias outer_s.
Left join it to the country table using the outer query's country_id column.
Calculate an AVG of high scoring matches per country in the main query.

SELECT
	c.name AS country,
    -- Calculate the average matches per season
	AVG(outer_s.matches) AS avg_seasonal_high_scores
FROM country AS c
-- Left join outer_s to country
LEFT JOIN (
  SELECT country_id, season,
         COUNT(id) AS matches
  FROM (
    SELECT country_id, season, id
	FROM match
	WHERE home_goal >= 5 OR away_goal >= 5) AS inner_s
  -- Close parentheses and alias the subquery
  GROUP BY country_id, season) AS outer_s
ON c.id = outer_s.country_id
GROUP BY country;



-- Common Table Expressions

-- we can write subqueries and name them before putting them in our main query
-- using WITH and AS statements
-- You can list one (or more) subqueries as common table expressions (CTEs) by declaring them ahead of your main query

-- this below query can be written using a common table expression (CTE) as shown under it
SELECT
  c.name AS country,
  COUNT(sub.id) AS matches
FROM country AS c
INNER JOIN (
  SELECT country_id, id 
  FROM match
  WHERE (home_goal + away_goal) >= 10) AS sub
ON c.id = sub.country_id
GROUP BY country;

-- Set up your CTE
WITH match_list AS (
    SELECT 
  		country_id, 
  		id
    FROM match
    WHERE (home_goal + away_goal) >= 10)
    
-- Select league and count of matches from the CTE
SELECT
    l.name AS league,
    COUNT(match_list.id) AS matches
FROM league AS l
-- Join the CTE to the league table
LEFT JOIN match_list ON l.id = match_list.country_id
GROUP BY l.name;


-- Just like a subquery in FROM, you can join tables inside a CTE:

-- Set up your CTE
WITH match_list AS (
  -- Select the league, date, home, and away goals
    SELECT 
  		l.name AS league, 
     	date, 
  		home_goal, 
  		away_goal,
       (m.home_goal + m.away_goal) AS total_goals
    FROM match AS m
    LEFT JOIN league as l ON m.country_id = l.id)
-- Select the league, date, home, and away goals from the CTE
SELECT league, date, home_goal, away_goal
FROM match_list
-- Filter by total goals
WHERE total_goals >= 10;


-- I wrote this below query with CTE
-- here CTE calculates total goals scored in each match in August of 2013/2014 season
WITH match_list AS (
  SELECT date, country_id,home_goal+away_goal AS aug_total_goal
  FROM match
  WHERE season = '2013/2014' AND EXTRACT(MONTH FROM date) = 8
)

-- using above CTE the query below calculates total goals scored in August of 2013/2014 season in each country/league
SELECT l.country_id, l.name, sum(aug_total_goal)
FROM match_list AS m
LEFT JOIN league AS l
ON m.country_id = l.country_id
GROUP BY l.country_id, l.name;


-- EXERCISE:
-- solving same problem with different query types
-- Let's solve a problem we've encountered a few times in this course so far -- How do you get both the home and away team names into one final query result?
-- Create a query that left joins team to match in order to get the identity of the home team. This becomes the subquery in the next step.
SELECT 
	m.id, 
    t.team_long_name AS hometeam
-- Left join team to match
FROM match AS m
LEFT JOIN team as t
ON m.hometeam_id = team_api_id;

-- Add a second subquery to the FROM statement to get the away team name, changing only the hometeam_id. Left join both subqueries to the match table on the id column.
SELECT
	m.date,
    -- Get the home and away team names
    hometeam,
    awayteam,
    m.home_goal,
    m.away_goal
FROM match AS m

-- Join the home subquery to the match table
LEFT JOIN (
  SELECT match.id, team.team_long_name AS hometeam
  FROM match
  LEFT JOIN team
  ON match.hometeam_id = team.team_api_id) AS home
ON home.id = m.id

-- Join the away subquery to the match table
LEFT JOIN (
  SELECT match.id, team.team_long_name AS awayteam
  FROM match
  LEFT JOIN team
  -- Get the away team ID in the subquery
  ON match.awayteam_id = team.team_api_id) AS away
ON away.id = m.id;


-- Let's solve the same problem using correlated subqueries -- How do you get both the home and away team names into one final query result?
-- Using a correlated subquery in the SELECT statement, match the team_api_id column from team to the hometeam_id from match:
SELECT
    m.date,
   (SELECT team_long_name
    FROM team AS t
    -- Connect the team to the match table
    WHERE t.team_api_id = m.hometeam_id) AS hometeam
FROM match AS m;

-- the join query code above can also be written as:
SELECT date, team_long_name AS hometeam
    FROM team AS t, match AS m
    -- Connect the team to the match table
    WHERE t.team_api_id = m.hometeam_id;
    

-- Create a second correlated subquery in SELECT, yielding the away team's name.
-- Select the home and away goal columns from match in the main query.
SELECT
    m.date,
    (SELECT team_long_name
     FROM team AS t
     WHERE t.team_api_id = m.hometeam_id) AS hometeam,
    -- Connect the team to the match table
    (SELECT team_long_name
     FROM team AS t
     WHERE t.team_api_id = m.awayteam_id) AS awayteam,
    -- Select home and away goals
     home_goal,
     away_goal
FROM match AS m;


-- Let's explore the final method - common table expressions. 
-- Common table expressions are similar to the subquery method for generating results, mainly differing in syntax and the order in which information is processed.
-- here notice that we can declare several CTE with one WITH statement by separating them with comma in between each part ( WITH home AS (), away AS() )
WITH home AS (
  SELECT m.id, m.date, 
  		 t.team_long_name AS hometeam, m.home_goal
  FROM match AS m
  LEFT JOIN team AS t 
  ON m.hometeam_id = t.team_api_id),
-- Declare and set up the away CTE
away AS (
  SELECT m.id, m.date, 
  		 t.team_long_name AS awayteam, m.away_goal
  FROM match AS m
  LEFT JOIN team AS t 
  ON m.awayteam_id = t.team_api_id)

-- Select date, home_goal, and away_goal
SELECT 
	home.date,
    home.hometeam,
    away.awayteam,
    home.home_goal,
    away.away_goal
-- Join away and home on the id column
FROM home
INNER JOIN away
ON home.id = away.id;



-- WINDOW FUNCTIONS

-- window functions are processed after every part of query except ORDER BY clause at the end
-- window function uses the resulting information from the query rather than the data set, which makes it run fast
-- window functions are available in PostgreSQL, Oracle, MySQL, but not in SQLite

-- The OVER() clause allows you to pass an aggregate function down a data set, similar to subqueries in SELECT. 
-- The OVER() clause offers significant benefits over subqueries in select -- namely, your queries will run faster

-- the query below calculates the average number of goals scored overall and then includes the aggregate value in each row using a window function.
SELECT 
	-- Select the id, country name, season, home, and away goals
	m.id, 
    c.name AS country, 
    m.season,
	m.home_goal,
	m.away_goal,
    -- Use a window to include the aggregate average in each row
	AVG(m.home_goal + m.away_goal) OVER() AS overall_avg
FROM match AS m
LEFT JOIN country AS c ON m.country_id = c.id;

-- RANK with OVER
-- Window functions allow you to create a RANK of information according to any variable you want to use to sort your data. 
-- When setting this up, you will need to specify what column/calculation you want to use to calculate your rank. 
-- This is done by including an ORDER BY clause inside the OVER() clause. Below is an example:
SELECT 
    id,
    RANK() OVER(ORDER BY home_goal) AS rank
FROM match;


-- another example: the window function below calculates the rank of average goals scored across all leagues in the database.
SELECT 
	-- Select the league name and average goals scored
	l.name AS league,
    AVG(m.home_goal + m.away_goal) AS avg_goals,
    -- Rank each league according to the average goals
    RANK() OVER(ORDER BY AVG(m.home_goal + m.away_goal)) AS league_rank
FROM league AS l
LEFT JOIN match AS m 
ON l.id = m.country_id
WHERE m.season = '2011/2012'
GROUP BY l.name
-- Order the query by the rank you created
ORDER BY league_rank;



-- OVER with a PARTITION
-- The PARTITION BY clause can be used to break out window averages by multiple data points (columns). 

SELECT
	date,
	season,
	home_goal,
	away_goal,
	CASE WHEN hometeam_id = 8673 THEN 'home' 
		 ELSE 'away' END AS warsaw_location,
    -- Calculate the average goals scored partitioned by season
    AVG(home_goal) OVER(PARTITION BY season) AS season_homeavg,
    AVG(away_goal) OVER(PARTITION BY season) AS season_awayavg
FROM match
-- Filter the data set for Legia Warszawa matches only
WHERE 
	hometeam_id = 8673 
    OR awayteam_id = 8673
ORDER BY (home_goal + away_goal) DESC;


-- In this exercise, you will calculate the average number home and away goals scored Legia Warszawa, and their opponents, partitioned by the month in each season.
SELECT 
	date,
	season,
	home_goal,
	away_goal,
	CASE WHEN hometeam_id = 8673 THEN 'home' 
         ELSE 'away' END AS warsaw_location,
	-- Calculate average goals partitioned by season and month
    AVG(home_goal) OVER(PARTITION BY season, 
         	EXTRACT(MONTH FROM date)) AS season_mo_home,
    AVG(away_goal) OVER(PARTITION BY season, 
            EXTRACT(MONTH FROM date)) AS season_mo_away
FROM match
WHERE 
	hometeam_id = 8673
    OR awayteam_id = 8673
ORDER BY (home_goal + away_goal) DESC;



-- Sliding windows

-- changes calculation by rows of the data set, such as running totals, cumulative averages etc
-- Sliding windows allow you to create running calculations between any two points in a window using functions such as PRECEDING, FOLLOWING, and CURRENT ROW.
-- You can calculate running counts, sums, averages, and other aggregate functions between any two points you specify in the data set.

SELECT 
	date,
	home_goal,
	away_goal,
    -- Create a running total and running average of home goals
    SUM(home_goal) OVER(ORDER BY date 
         ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS running_total,
    AVG(home_goal) OVER(ORDER BY date 
         ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS running_avg
FROM match
WHERE 
	hometeam_id = 9908 
	AND season = '2011/2012';

-- Result:
date	home_goal away_goal running_total  running_avg
2011-08-14	2	2	2	2.0000000000000000
2011-08-27	3	1	5	2.5000000000000000
2011-09-18	2	2	7	2.3333333333333333
2011-10-01	3	0	10	2.5000000000000000
2011-10-22	1	4	11	2.2000000000000000
2011-11-06	6	4	17	2.8333333333333333
2011-12-04	2	6	19	2.7142857142857143
2011-12-11	2	2	21	2.6250000000000000
2012-01-22	1	1	22	2.4444444444444444
2012-02-12	1	1	23	2.3000000000000000
2012-02-19	3	0	26	2.3636363636363636
2012-03-04	0	0	26	2.1666666666666667
2012-03-18	3	1	29	2.2307692307692308
2012-03-30	3	2	32	2.2857142857142857


-- In this exercise, you will slightly modify the query from the previous exercise by sorting the data set in reverse order 
--and calculating a backward running total from the CURRENT ROW to the end of the data set (earliest record).

SELECT 
	-- Select the date, home goal, and away goals
	date,
    home_goal,
    away_goal,
    -- Create a running total and running average of home goals
    SUM(home_goal) OVER(ORDER BY date DESC
         ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS running_total,
    AVG(home_goal) OVER(ORDER BY date DESC
         ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS running_avg
FROM match
WHERE 
	awayteam_id = 9908 
    AND season = '2011/2012';
    
-- result
date	home_goal away_goal	running_total	running_avg
2012-03-25	3	1	21	1.5000000000000000
2012-03-11	1	1	18	1.3846153846153846
2012-02-26	1	0	17	1.4166666666666667
2012-02-05	0	2	16	1.4545454545454545
2012-01-28	2	0	16	1.6000000000000000
2011-12-17	1	0	14	1.5555555555555556
2011-11-25	2	0	13	1.6250000000000000
2011-11-20	2	2	11	1.5714285714285714
2011-10-30	3	1	9	1.5000000000000000
2011-10-15	1	0	6	1.2000000000000000
2011-09-24	1	0	5	1.2500000000000000
2011-09-11	2	3	4	1.3333333333333333
2011-08-20	2	1	2	1.0000000000000000


-- FINAL EXERCISE
-- For this exercise, you will be using all of these concepts to generate a list of matches in which 
--Manchester United was defeated during the 2014/2015 English Premier League season.

--Your first task is to create the first query that filters for matches where Manchester United played as the home team.
--This will become a common table expression in a later exercise.
SELECT 
	m.id, 
    t.team_long_name,
    -- Identify matches as home/away wins or ties
	CASE WHEN m.home_goal > m.away_goal THEN 'MU Win'
		 WHEN m.home_goal < m.away_goal THEN 'MU Loss'
         ELSE 'Tie' END AS outcome
FROM match AS m
-- Left join team on the home team ID and team API id
LEFT JOIN team AS t 
ON m.hometeam_id = t.team_api_id
WHERE 
	-- Filter for 2014/2015 and Manchester United as the home team
	season = '2014/2015'
	AND t.team_long_name = 'Manchester United';


-- Now that you have a query identifying the home team in a match, you will perform a similar set of steps to identify the away team. 
--Just like the previous step, you will join the match and team tables.
SELECT 
	m.id, 
    t.team_long_name,
    -- Identify matches as home/away wins or ties
	CASE WHEN m.home_goal > away_goal THEN 'MU Loss'
		 WHEN m.home_goal <away_goal THEN 'MU Win'
         ELSE 'Tie' END AS outcome
-- Join team table to the match table
FROM match AS m
LEFT JOIN team AS t 
ON m.awayteam_id = t.team_api_id
WHERE 
	-- Filter for 2014/2015 and Manchester United as the away team
	season = '2014/2015'
	AND t.team_long_name = 'Manchester United';


-- Now that you've created the two subqueries identifying the home and away team opponents, 
--it's time to rearrange your query with the home and away subqueries as Common Table Expressions (CTEs).
-- Continue building the query to extract all matches played by Manchester United in the 2014/2015 season.
-- Set up the home team CTE
WITH home AS (
  SELECT m.id, t.team_long_name,
	  CASE WHEN m.home_goal > m.away_goal THEN 'MU Win'
		   WHEN m.home_goal < m.away_goal THEN 'MU Loss' 
  		   ELSE 'Tie' END AS outcome
  FROM match AS m
  LEFT JOIN team AS t ON m.hometeam_id = t.team_api_id),
-- Set up the away team CTE
away AS (
  SELECT m.id, t.team_long_name,
	  CASE WHEN m.home_goal > m.away_goal THEN 'MU Win'
		   WHEN m.home_goal < m.away_goal THEN 'MU Loss' 
  		   ELSE 'Tie' END AS outcome
  FROM match AS m
  LEFT JOIN team AS t ON m.awayteam_id = t.team_api_id)
-- Select team names, the date and goals
SELECT DISTINCT
    m.date,
    home.team_long_name AS home_team,
    away.team_long_name AS away_team,
    m.home_goal,
    m.away_goal
-- Join the CTEs onto the match table
FROM match AS m
LEFT JOIN home ON m.id = home.id
LEFT JOIN away ON m.id = away.id
WHERE m.season = '2014/2015'
      AND (home.team_long_name = 'Manchester United' 
           OR away.team_long_name = 'Manchester United');

--Result:
date	home_team	away_team	home_goal	away_goal
2014-08-16	Manchester United	Swansea City	1	2
2014-08-24	Sunderland	Manchester United	1	1
2014-08-30	Burnley	Manchester United	0	0
2014-09-14	Manchester United	Queens Park Rangers	4	0
2014-09-21	Leicester City	Manchester United	5	3
2014-09-27	Manchester United	West Ham United	2	1
2014-10-05	Manchester United	Everton	2	1
2014-10-20	West Bromwich Albion	Manchester United	2	2
2014-10-26	Manchester United	Chelsea	1	1
2014-11-02	Manchester City	Manchester United	1	0
2014-11-08	Manchester United	Crystal Palace	1	0
...


-- let's add a window function to the main query that ranks matches by the absolute value of the difference between home_goal and away_goal. 
--This allows us to directly compare the difference in scores without having to consider whether Manchester United played as the home or away team!

-- Set up the home team CTE
WITH home AS (
  SELECT m.id, t.team_long_name,
	  CASE WHEN m.home_goal > m.away_goal THEN 'MU Win'
		   WHEN m.home_goal < m.away_goal THEN 'MU Loss' 
  		   ELSE 'Tie' END AS outcome
  FROM match AS m
  LEFT JOIN team AS t ON m.hometeam_id = t.team_api_id),
-- Set up the away team CTE
away AS (
  SELECT m.id, t.team_long_name,
	  CASE WHEN m.home_goal > m.away_goal THEN 'MU Loss'
		   WHEN m.home_goal < m.away_goal THEN 'MU Win' 
  		   ELSE 'Tie' END AS outcome
  FROM match AS m
  LEFT JOIN team AS t ON m.awayteam_id = t.team_api_id)
-- Select columns and and rank the matches by date
SELECT DISTINCT
    m.date,
    home.team_long_name AS home_team,
    away.team_long_name AS away_team,
    m.home_goal, m.away_goal,
    RANK() OVER(ORDER BY ABS(home_goal - away_goal) DESC) as match_rank
-- Join the CTEs onto the match table
FROM match AS m
LEFT JOIN home ON m.id = home.id
LEFT JOIN away ON m.id = away.id
WHERE m.season = '2014/2015'
      AND ((home.team_long_name = 'Manchester United' AND home.outcome = 'MU Loss')
      OR (away.team_long_name = 'Manchester United' AND away.outcome = 'MU Loss'));

